<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/jyj_64.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/jyj_64.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/jyj_32.png?v=5.1.4">


  <link rel="mask-icon" href="/images/jyj.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据结构与算法,">










<meta name="description" content="一直都想补补数据结构和算法的知识，前端时间在《极客时间》上看到《数据结构与算法之美》这门课好像挺火，于是就买了下来。学习的时候不妨做做笔记，也充实一下我这好久不更的博客。">
<meta name="keywords" content="数据结构与算法">
<meta property="og:type" content="article">
<meta property="og:title" content="《数据结构与算法之美》学习笔记">
<meta property="og:url" content="http://jiayueji.cn/2019/03/12/《数据结构与算法之美》学习笔记/index.html">
<meta property="og:site_name" content="Charles">
<meta property="og:description" content="一直都想补补数据结构和算法的知识，前端时间在《极客时间》上看到《数据结构与算法之美》这门课好像挺火，于是就买了下来。学习的时候不妨做做笔记，也充实一下我这好久不更的博客。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure.jpg?raw=true">
<meta property="og:image" content="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_compare.jpg?raw=true">
<meta property="og:image" content="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_skip_list.jpg?raw=true">
<meta property="og:image" content="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_sanliebiao_lianbiaofa.jpg?raw=true">
<meta property="og:image" content="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_kuorong.jpg?raw=true">
<meta property="og:image" content="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_lru.jpg?raw=true">
<meta property="og:updated_time" content="2019-03-31T13:48:47.948Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《数据结构与算法之美》学习笔记">
<meta name="twitter:description" content="一直都想补补数据结构和算法的知识，前端时间在《极客时间》上看到《数据结构与算法之美》这门课好像挺火，于是就买了下来。学习的时候不妨做做笔记，也充实一下我这好久不更的博客。">
<meta name="twitter:image" content="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure.jpg?raw=true">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jiayueji.cn/2019/03/12/《数据结构与算法之美》学习笔记/">





  <title>《数据结构与算法之美》学习笔记 | Charles</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Charles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jiayueji.cn/2019/03/12/《数据结构与算法之美》学习笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/android-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Charles">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">《数据结构与算法之美》学习笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T20:00:00+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/12/《数据结构与算法之美》学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2019/03/12/《数据结构与算法之美》学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/12/《数据结构与算法之美》学习笔记/" class="leancloud_visitors" data-flag-title="《数据结构与算法之美》学习笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  54
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>一直都想补补数据结构和算法的知识，前端时间在《极客时间》上看到《数据结构与算法之美》这门课好像挺火，于是就买了下来。学习的时候不妨做做笔记，也充实一下我这好久不更的博客。</p>
<a id="more"></a>
<h1 id="为什么要学习数据结构和算法？"><a href="#为什么要学习数据结构和算法？" class="headerlink" title="为什么要学习数据结构和算法？"></a>为什么要学习数据结构和算法？</h1><p>这一节没啥</p>
<h1 id="如何抓住重点，系统高效地学习数据结构与算法？"><a href="#如何抓住重点，系统高效地学习数据结构与算法？" class="headerlink" title="如何抓住重点，系统高效地学习数据结构与算法？"></a>如何抓住重点，系统高效地学习数据结构与算法？</h1><p>作者对数据结构和算法的定义：</p>
<p>从广义上讲，数据结构就是指<strong>一组数据的存储结构</strong>。算法就是<strong>操作数据的一组方法</strong>。</p>
<p>数据结构和算法的关系：</p>
<p><strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。</p>
<p>数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。</p>
<p>下图几乎涵盖了所有数据结构和算法书籍都会讲到的知识点： <img src="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure.jpg?raw=true" width="600"></p>
<p>作者总结的 20 个最常用的、最基础数据结构与算法：</p>
<p>10 个数据结构：</p>
<p>数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树</p>
<p>10 个算法</p>
<p>递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</p>
<h3 id="学习技巧："><a href="#学习技巧：" class="headerlink" title="学习技巧："></a>学习技巧：</h3><ol>
<li><p>边学边练，适度刷题</p>
</li>
<li><p>多问、多思考、多互动</p>
</li>
<li><p>坚持</p>
</li>
<li><p>反复迭代，不断沉淀</p>
</li>
</ol>
<h1 id="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"><a href="#复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？" class="headerlink" title="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"></a>复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</h1><p>使用<strong>时间、空间复杂度分析</strong>来衡量算法代码的执行效率。</p>
<p><strong>复杂度分析是整个算法学习的精髓</strong></p>
<h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><p>算法的执行效率，粗略地讲，就是算法代码执行的时间。</p>
<p>举例 1：如下代码运行时间为 T(n) = (2n+3)*unit_time</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  for (; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例 2：如下代码运行时间为 T(n) = (2n^2+2n+3)*unit_time</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  int j = 1;</span><br><span class="line">  for (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = 1;</span><br><span class="line">    for (; j &lt;= n; ++j) &#123;</span><br><span class="line">      sum = sum +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这两段代码运行时间总结出规律：<strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong>，即 T(n) = O(f(n))，这就是<strong>大 O 时间复杂度表示法</strong>，他并不表示代码真正的运行时间，而是<strong>代码执行时间随数据规模增长的变化趋势</strong>。</p>
<p>如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)；T(n) = O(n2)。</p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>三个小技巧：</p>
<ol>
<li><p>只关注循环执行次数最多的一段代码</p>
</li>
<li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<p>T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), g(n)))</p>
</li>
<li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<p>T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n))</p>
</li>
</ol>
<h2 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h2><p>常见的复杂度量级（按数量级递增）</p>
<ul>
<li>常量阶 O(1)</li>
<li>指数阶 O(logn)</li>
<li>线性阶 O(n)</li>
<li>线性对数阶 O(nlogn)</li>
<li>平方阶 O(n^2)</li>
<li>立方阶 O(n^3)</li>
<li>k 次方阶 O(n^k)</li>
<li>指数阶 O(2^n)</li>
<li>阶乘阶 O(n!)</li>
</ul>
<p>其中<strong>指数阶</strong>和<strong>阶乘阶</strong>被称为<strong>非多项式量级</strong>，其余为<strong>多项式量级</strong>。我们主要来看几种常见的多项式时间复杂度。</p>
<ol>
<li><p>O(1)</p>
<p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。<strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 Ο(1)</strong>。 举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 8;</span><br><span class="line">int j = 6;</span><br><span class="line">int sum = i + j;</span><br></pre></td></tr></table></figure>
</li>
<li><p>O(logn)、O(nlogn)</p>
<p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=1;</span><br><span class="line">while (i &lt;= n)  &#123;</span><br><span class="line">   i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。相当于求 2^x=n，解得 x=log₂n，所以这段代码时间复杂度为 O(log₂n)。</p>
<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。因为 log₃n=log₃2*log₂n，而 log₃2 是一个常量，可以忽略。</p>
</li>
<li><p>O(m+n)、O(m*n)</p>
</li>
</ol>
<p>下面一段代码的复杂度由两个数据的规模来决定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">  int sum_1 = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  for (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int sum_2 = 0;</span><br><span class="line">  int j = 1;</span><br><span class="line">  for (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，第一段代码复杂度为 m，第二段代码复杂度为 n。我们无法事先评估 m 和 n 哪个量级大，所以不能简单地使用加法法则省略其中一个，所以上段代码复杂度为 O(m+n)。此时 T1(m) + T2(n) = O(f(m) + g(n))。</p>
<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>前面讲过，<strong>时间复杂度表示算法的执行时间与数据规模之间的增长关系</strong>，类比一下，<strong>空间复杂度表示算法的存储空间与数据规模之间的增长关系</strong>。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void print(int n) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int[] a = new int[n];</span><br><span class="line">  for (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (i = n-1; i &gt;= 0; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上段代码第二行申请了一个空间存储变量 i，但是他是常量阶，可以忽略。第三行代码申请了一个大小为 n 的 int 类型数组，除此之外其他代码没有占用更多空间，所以该段代码的空间复杂度为 O(n)。</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握这些内容已经足够了。</p>
<p><img src="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_compare.jpg?raw=true" width="600"></p>
<h1 id="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"><a href="#复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"></a>复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</h1><p>4 个知识点：</p>
<ul>
<li>最好情况时间复杂度</li>
<li>最坏情况时间复杂度</li>
<li>平均情况时间复杂度</li>
<li>均摊时间复杂度</li>
</ul>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> // n 表示数组 array 的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码遍历 array 并从中查找变量 x 出现的位置。如果没有找到，就返回 -1。这段代码复杂度为 O(n)。</p>
<p>优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// n 表示数组 array 的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p>
<p>为了表示代码在不同情况下的不同时间复杂度，需要引入三个概念：<strong>最好情况时间复杂度</strong>、<strong>最坏情况时间复杂度</strong>和<strong>平均情况时间复杂度</strong>。</p>
<p>尝试计算下上段代码的平均情况时间复杂度：</p>
<p>假设 x 在数组中和不在数组中的概率相同，即都是 1/2，而 x 在数组中各个位置出现的概率也相同，即都是 1/2n。若 x 出现在数组中，那么出现在第 p 位置时，时间复杂度就是 p/n2，若 x 不出现在数组中，还是要将数组遍历一遍，时间复杂度就是 n/2。那么将各种情况都考虑一下的话，上段代码的时间复杂度就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1/2n + 2/2n + ... + n/2n = (3n + 1)/n</span><br></pre></td></tr></table></figure>
<p>用大 O 表示法还是 O(n)。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// array 表示一个长度为 n 的数组</span><br><span class="line">// 代码中的 array.length 就等于 n</span><br><span class="line">int[] array = new int[n];</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">   if (count == array.length) &#123;</span><br><span class="line">      int sum = 0;</span><br><span class="line">      for (int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[0] = sum;</span><br><span class="line">      count = 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<p>这段代码的平均复杂度是 O(1)。</p>
<p>使用摊还时间复杂度分析：每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1)的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。</p>
<p><strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong>。</p>
<h1 id="数组：为什么很多编程语言中数组都从-0-开始编号？"><a href="#数组：为什么很多编程语言中数组都从-0-开始编号？" class="headerlink" title="数组：为什么很多编程语言中数组都从 0 开始编号？"></a>数组：为什么很多编程语言中数组都从 0 开始编号？</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><ul>
<li><p>数组</p>
<p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
<ul>
<li><p>线性表</p>
<p>数组，链表、队列、栈。</p>
</li>
<li><p>非线性表</p>
<p>二叉树、堆、图。</p>
</li>
<li><p>连续的内存空间和相同类型的数据</p>
</li>
</ul>
</li>
</ul>
<h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2><p>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你发现问题了吗？这段代码的运行结果并非是打印三行“helloword”，而是会无限打印“hello world”，这是为什么呢？</p>
<p>我们知道（在看答案之前我也是不知道的），在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。</p>
<h2 id="java-小知识"><a href="#java-小知识" class="headerlink" title="java 小知识"></a>java 小知识</h2><p>ArrayList<strong>将很多数组操作的细节封装起来</strong>，还支持<strong>动态扩容</strong>：每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。</p>
<p>这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    users.add(xxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上段代码，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。</p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>从数组存储的内存模型上看，“下标”确切的定义是“偏移”。如果用 a 来表示数组的首地址，那么数组第一个元素就是 a 偏移 0 个位置的地址即 a[0]。</p>
<p>最主要的原因还是<strong>历史原因</strong>。</p>
<h1 id="链表（上）：如何实现-LRU-缓存淘汰算法"><a href="#链表（上）：如何实现-LRU-缓存淘汰算法" class="headerlink" title="链表（上）：如何实现 LRU 缓存淘汰算法?"></a>链表（上）：如何实现 LRU 缓存淘汰算法?</h1><h2 id="链表-VS-数组性能大比拼"><a href="#链表-VS-数组性能大比拼" class="headerlink" title="链表 VS 数组性能大比拼"></a>链表 VS 数组性能大比拼</h2><table>
<thead>
<tr>
<th>时间复杂度</th>
<th>链表</th>
<th>数组</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<h2 id="啥是-LRU-缓存淘汰算法"><a href="#啥是-LRU-缓存淘汰算法" class="headerlink" title="啥是 LRU 缓存淘汰算法?"></a>啥是 LRU 缓存淘汰算法?</h2><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p>
<p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：<strong>先进先出策略 FIFO（FirstIn，First Out）</strong>、<strong>最少使用策略 LFU（Least Frequently Used）</strong>、<strong>最近最少使用策略 LRU（Least Recently Used）</strong>。</p>
<p>思路：</p>
<p>维护一个有序单链表，越靠近链表尾部的数据时越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p>
<ol>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li>
<li><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p>
<ul>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部</li>
</ul>
</li>
</ol>
<h1 id="链表（下）：如何轻松写出正确的链表代码？"><a href="#链表（下）：如何轻松写出正确的链表代码？" class="headerlink" title="链表（下）：如何轻松写出正确的链表代码？"></a>链表（下）：如何轻松写出正确的链表代码？</h1><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ol>
<li><p>理解指针或引用的含义</p>
<p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p>
<p>举例：p-&gt;next = q，p 结点中的 next 指针存储了 q 结点的内存地址；p-&gt;next=p-&gt;next-&gt;next，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址（也就是删除了 p 节点的下一个节点）。</p>
</li>
<li><p>警惕指针丢失和内存泄漏</p>
<p>举例：如下代码就会造成指针丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = x;  // 将 p 的 next 指针指向 x 结点；</span><br><span class="line">x-&gt;next = p-&gt;next;  // 将 x 的结点的 next 指针指向 b 结点；</span><br></pre></td></tr></table></figure>
<p>只要将两行代码顺序互换即可。</p>
</li>
<li><p>利用哨兵简化实现难度</p>
</li>
</ol>
<p>链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head 指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。</p>
<ul>
<li><p>未引入“哨兵”的情况</p>
<p>如果在 p 节点后插入一个节点，只需 2 行代码即可搞定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_node—&gt;next = p—&gt;next;</span><br><span class="line">p—&gt;next = new_node;</span><br></pre></td></tr></table></figure>
<p>但，若向空链表中插入一个节点，则代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(head == null)&#123;</span><br><span class="line">head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要删除节点 p 的后继节点，只需 1 行代码即可搞定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p—&gt;next = p—&gt;next—&gt;next;</span><br></pre></td></tr></table></figure>
<p>但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(head—&gt;next == null)&#123;</span><br><span class="line">    head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。</p>
</li>
<li><p>引入“哨兵”的情况</p>
<p>“哨兵”节点不存储数据，无论链表是否为空，head 指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。</p>
</li>
</ul>
<ol start="4">
<li><p>重点留意边界条件处理</p>
<ul>
<li>如果链表为空时，代码是否能正常工作？</li>
<li>如果链表只包含一个结点时，代码是否能正常工作？</li>
<li>如果链表只包含两个结点时，代码是否能正常工作？</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li>
</ul>
</li>
<li><p>举例画图，辅助思考</p>
</li>
<li><p>多写多练，没有捷径</p>
</li>
</ol>
<h2 id="作者精选的-5-个常见链表操作"><a href="#作者精选的-5-个常见链表操作" class="headerlink" title="作者精选的 5 个常见链表操作"></a>作者精选的 5 个常见链表操作</h2><ul>
<li>单链表反转</li>
<li>链表中环的检测</li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第 n 个结点</li>
<li>求链表的中间结点</li>
</ul>
<h1 id="栈：如何实现浏览器的前进和后退功能？"><a href="#栈：如何实现浏览器的前进和后退功能？" class="headerlink" title="栈：如何实现浏览器的前进和后退功能？"></a>栈：如何实现浏览器的前进和后退功能？</h1><p><strong>后进者先出，先进者后出，这就是典型的“栈”结构</strong>。</p>
<p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构</strong>。</p>
<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 基于数组实现的顺序栈</span><br><span class="line">public class ArrayStack &#123;</span><br><span class="line">  private String[] items;  // 数组</span><br><span class="line">  private int count;       // 栈中元素个数</span><br><span class="line">  private int n;           // 栈的大小</span><br><span class="line"></span><br><span class="line">  // 初始化数组，申请一个大小为 n 的数组空间</span><br><span class="line">  public ArrayStack(int n) &#123;</span><br><span class="line">    this.items = new String[n];</span><br><span class="line">    this.n = n;</span><br><span class="line">    this.count = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 入栈操作</span><br><span class="line">  public boolean push(String item) &#123;</span><br><span class="line">    // 数组空间不够了，直接返回 false，入栈失败。</span><br><span class="line">    if (count == n) return false;</span><br><span class="line">    // 将 item 放到下标为 count 的位置，并且 count 加一</span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 出栈操作</span><br><span class="line">  public String pop() &#123;</span><br><span class="line">    // 栈为空，则直接返回 null</span><br><span class="line">    if (count == 0) return null;</span><br><span class="line">    // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span><br><span class="line">    String tmp = items[count-1];</span><br><span class="line">    --count;</span><br><span class="line">    return tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ul>
<li><p>函数调用栈</p>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
</li>
<li><p>表达式求值</p>
<p>利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出 2 个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。</p>
</li>
<li><p>括号匹配</p>
<p>用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。</p>
</li>
<li><p>浏览器的前进后退</p>
<p>我们使用两个栈 X 和 Y，我们把首次浏览的页面依次压如栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据一次放入 Y 栈。当点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，说明没有页面可以继续后退浏览了。当 Y 栈没有数据，那就说明没有页面可以点击前进浏览了。</p>
</li>
</ul>
<h1 id="队列：队列在线程池等有限资源池中的应用"><a href="#队列：队列在线程池等有限资源池中的应用" class="headerlink" title="队列：队列在线程池等有限资源池中的应用"></a>队列：队列在线程池等有限资源池中的应用</h1><p><strong>先进者先出，这就是典型的“队列”</strong>。</p>
<p>队列最基本的操作有两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</p>
<p>用数组实现的队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组实现的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 tail == n 表示队列已经满了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了</span></span><br><span class="line">    String ret = items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。可以用<strong>数据搬移</strong>解决。我们在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h2><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回（生产者 - 消费者模型）。</p>
<p>阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题。</p>
<p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。</p>
<p><strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队</strong>。</p>
<h1 id="递归：如何用三行代码找到“最终推荐人”？"><a href="#递归：如何用三行代码找到“最终推荐人”？" class="headerlink" title="递归：如何用三行代码找到“最终推荐人”？"></a>递归：如何用三行代码找到“最终推荐人”？</h1><h2 id="递归需要满足的三个条件。"><a href="#递归需要满足的三个条件。" class="headerlink" title="递归需要满足的三个条件。"></a>递归需要满足的三个条件。</h2><ol>
<li><p>一个问题的解可以分解为几个子问题的解</p>
</li>
<li><p>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全相同</p>
</li>
<li><p>存在递归终止条件</p>
</li>
</ol>
<p>写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong>。</p>
<p>举例：</p>
<p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p>
<p>可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure>
<p>终止条件就是 f(1)=1，f(2)=2。</p>
<p>最终的递归代码就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int f(n) &#123;</span><br><span class="line">  if (n == 1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (n == 2) &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  return f(1) + f(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>作者在“栈”那一节讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>在上段代码中，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p>
<p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p>
<p>改造代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">  if (n == 1) return 1;</span><br><span class="line">  if (n == 2) return 2;</span><br><span class="line"></span><br><span class="line">  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span><br><span class="line">  if (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    return hasSovledList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int ret = f(n-1) + f(n-2);</span><br><span class="line">  hasSovledList.put(n, ret);</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h2><p>递归有利有弊，利是<strong>递归代码的表达力很强，写起来非常简洁</strong>；而弊就是<strong>空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多</strong>等问题。</p>
<p>上个例子代码改成非递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  if (n == 1) return 1;</span><br><span class="line">  if (n == 2) return 2;</span><br><span class="line"></span><br><span class="line">  int ret = 0;</span><br><span class="line">  int pre = 2;</span><br><span class="line">  int prepre = 1;</span><br><span class="line">  for (int i = 3; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那是不是所有的递归代码都可以改为这种迭代循环的非递归写法呢？是的。</p>
<p>因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p>
<p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>
<h1 id="排序（上）：为什么插入排序比冒泡排序更受欢迎？"><a href="#排序（上）：为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="排序（上）：为什么插入排序比冒泡排序更受欢迎？"></a>排序（上）：为什么插入排序比冒泡排序更受欢迎？</h1><h2 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h2><ul>
<li><p>排序算法的执行效率</p>
<p>对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：</p>
<ol>
<li><p>最好情况、最坏情况、平均情况时间复杂度</p>
</li>
<li><p>时间复杂度的系数、常数、低阶</p>
</li>
<li><p>比较次数和交换（或移动）次数</p>
</li>
</ol>
</li>
<li><p>排序算法的内存消耗</p>
<p>排序算法的内存消耗可以通过空间复杂度来衡量。</p>
</li>
<li><p>排序算法的稳定性</p>
<p>稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
</li>
</ul>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡排序，a 表示数组，n 表示数组大小</span><br><span class="line">public void bubbleSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;= 1) return;</span><br><span class="line"></span><br><span class="line"> for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    // 提前退出冒泡循环的标志位</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    for (int j = 0; j &lt; n - i - 1; ++j) &#123;</span><br><span class="line">      if (a[j] &gt; a[j+1]) &#123; // 交换</span><br><span class="line">        int tmp = a[j];</span><br><span class="line">        a[j] = a[j+1];</span><br><span class="line">        a[j+1] = tmp;</span><br><span class="line">        flag = true;  // 表示有数据交换</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!flag) break;  // 没有数据交换，提前退出</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法（1）是原地排序算法，（2）是稳定的排序算法，（3）时间复杂度为 O(n²)。</p>
<p><strong>冒泡排序算法的时间复杂度</strong></p>
<p>最好情况时间复杂度是 O(n)，最坏情况时间复杂度为 O(n²)，平均时间复杂度就是加权平均期望时间复杂度。</p>
<p>对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。我们引入“<strong>有序度</strong>”和“<strong>逆序度</strong>”这两个概念。</p>
<p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure>
<p>比如：[2, 4, 3, 1, 5, 6]这组数据的有序度是 11，因为其有序元素对个数为 11，分别是：[2, 4]、[2, 3]、[2, 5]、[2, 6]、[4, 5]、[4， 6]、[3, 5]、[3, 6]、[1, 5]、[1, 6]、[5, 6]。</p>
<p>对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。</p>
<p><strong>逆序度</strong>的定义正好跟<strong>有序度</strong>相反。</p>
<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 插入排序，a 表示数组，n 表示数组大小</span><br><span class="line">public void insertionSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;= 1) return;</span><br><span class="line"></span><br><span class="line">  for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">    int value = a[i];</span><br><span class="line">    int j = i - 1;</span><br><span class="line">    // 查找插入的位置</span><br><span class="line">    for (; j &gt;= 0; --j) &#123;</span><br><span class="line">      if (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+1] = a[j];  // 数据移动</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+1] = value; // 插入数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序算法（1）是原地排序算法，（2）是稳定的排序算法，（3）时间复杂度为 O(n²)。</p>
<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void selectSort(int[] a, int n) &#123;</span><br><span class="line">  if(n&lt;=1) return;</span><br><span class="line">  for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">    int min=i;</span><br><span class="line">    for(int j=i;j&lt;n;j++)&#123;</span><br><span class="line">      if(a[j] &lt; a[min]) min=j;</span><br><span class="line">    &#125;</span><br><span class="line">    if(min != i)&#123;</span><br><span class="line">      int temp=a[i];</span><br><span class="line">      a[i]=a[min];</span><br><span class="line">      a[min]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序算法（1）是原地排序算法，（2）是不稳定的排序算法，（3）时间复杂度为 O(n²)。</p>
<h2 id="问题：插入排序和冒泡排序的时间复杂度相同，都是-O-n²-，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？"><a href="#问题：插入排序和冒泡排序的时间复杂度相同，都是-O-n²-，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？" class="headerlink" title="问题：插入排序和冒泡排序的时间复杂度相同，都是 O(n²)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？"></a>问题：<strong>插入排序和冒泡排序的时间复杂度相同，都是 O(n²)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢</strong>？</h2><p>从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡排序中数据的交换操作：</span><br><span class="line">if (a[j] &gt; a[j+1]) &#123; // 交换</span><br><span class="line">   int tmp = a[j];</span><br><span class="line">   a[j] = a[j+1];</span><br><span class="line">   a[j+1] = tmp;</span><br><span class="line">   flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入排序中数据的移动操作：</span><br><span class="line">if (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+1] = a[j];  // 数据移动</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排序（下）：如何用快排思想在-O-n-内查找第-K-大元素？"><a href="#排序（下）：如何用快排思想在-O-n-内查找第-K-大元素？" class="headerlink" title="排序（下）：如何用快排思想在 O(n)内查找第 K 大元素？"></a>排序（下）：如何用快排思想在 O(n)内查找第 K 大元素？</h1><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p>归并排序使用的就是<strong>分治思想</strong>。</p>
<p><strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span></span><br><span class="line">  <span class="keyword">int</span> q = p + (r - p)/<span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 分治递归</span></span><br><span class="line">  mergeSortInternally(a, p, q);</span><br><span class="line">  mergeSortInternally(a, q+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">  merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = p;</span><br><span class="line">  <span class="keyword">int</span> j = q+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 初始化变量i, j, k</span></span><br><span class="line">  <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>]; <span class="comment">// 申请一个大小跟a[p...r]一样的临时数组</span></span><br><span class="line">  <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++]; <span class="comment">// i++等于i:=i+1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">  <span class="keyword">int</span> start = i;</span><br><span class="line">  <span class="keyword">int</span> end = q;</span><br><span class="line">  <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">    start = j;</span><br><span class="line">    end = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    tmp[k++] = a[start++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将tmp中的数组拷贝回a[p...r]</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123;</span><br><span class="line">    a[p+i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序算法（1）是稳定的排序算法，（2）时间复杂度为 O(nlogn)，（3）空间复杂度是 O(n)。</p>
<p>时间复杂度计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br><span class="line"></span><br><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line">     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span><br><span class="line">     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line">     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     = 2^k * T(n/2^k) + k * n</span><br><span class="line">     ......</span><br><span class="line">     = 2^kT(n/2^k)+kn</span><br><span class="line"></span><br><span class="line">当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log₂n，所以时间复杂度为 O(nlogn)。</span><br></pre></td></tr></table></figure>
<h2 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> q = partition(a, p, r); <span class="comment">// 获取分区点</span></span><br><span class="line">  quickSortInternally(a, p, q-<span class="number">1</span>);</span><br><span class="line">  quickSortInternally(a, q+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivot = a[r];</span><br><span class="line">  <span class="keyword">int</span> i = p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = p; j &lt; r; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[j] &lt; pivot) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">        a[i++] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">  a[i] = a[r];</span><br><span class="line">  a[r] = tmp;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解答开篇-1"><a href="#解答开篇-1" class="headerlink" title="解答开篇"></a>解答开篇</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static int kthSmallest(int[] arr, int k) &#123;</span><br><span class="line">        if (arr == null || arr.length &lt; k) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int partition = partition(arr, 0, arr.length - 1);</span><br><span class="line">        while (partition + 1 != k) &#123;</span><br><span class="line">            if (partition + 1 &lt; k) &#123;</span><br><span class="line">                partition = partition(arr, partition + 1, arr.length - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                partition = partition(arr, 0, partition - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return arr[partition];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int partition(int[] arr, int p, int r) &#123;</span><br><span class="line">        int pivot = arr[r];</span><br><span class="line"></span><br><span class="line">        int i = p;</span><br><span class="line">        for (int j = p; j &lt; r; j++) &#123;</span><br><span class="line">            // 这里要是 &lt;= ，不然会出现死循环，比如查找数组 [1,1,2] 的第二小的元素</span><br><span class="line">            if (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(arr, i, r);</span><br><span class="line"></span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        if (i == j) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</p>
<p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p>
<p>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平平均情况下时间复杂度都是 O(nlogn)。</p>
<h1 id="线性排序：如何根据年龄给-100-万用户数据排序？"><a href="#线性排序：如何根据年龄给-100-万用户数据排序？" class="headerlink" title="线性排序：如何根据年龄给 100 万用户数据排序？"></a>线性排序：如何根据年龄给 100 万用户数据排序？</h1><p>线性排序（Linear sort）算法：桶排序、计数排序、基数排序。</p>
<h2 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h2><p>将要排序的（n 个）数据分到几个有序的（m 个）桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p><strong>桶排序比较适合用在外部排序中</strong>。</p>
<h2 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h2><p>计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数</strong>。</p>
<h2 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h2><p>问题：假设我们有 10 万个手机号码，希望将这 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p>
<p>先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。</p>
<p>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>
<h1 id="排序优化：如何实现一个通用的、高性能的排序函数？"><a href="#排序优化：如何实现一个通用的、高性能的排序函数？" class="headerlink" title="排序优化：如何实现一个通用的、高性能的排序函数？"></a>排序优化：如何实现一个通用的、高性能的排序函数？</h1><p>如果要实现一个通用的、高效率的排序函数，我们应该选择哪种排序算法？我们先回顾一下前面讲过的几种排序算法。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>稳定排序</th>
<th>原地排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n²)</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n)</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n + k)(k 是数据范围)</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(dn)(d 是维度)</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n2)的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p>
<p>时间复杂度是 O(nlogn) 的排序算法不止一个，我们已经讲过的有归并排序、快速排序，后面讲堆的时候我们还会讲到堆排序。堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。</p>
<h2 id="优化快速排序"><a href="#优化快速排序" class="headerlink" title="优化快速排序"></a>优化快速排序</h2><p>最坏情况下快速排序的时间复杂度是 O(n2)，这种 O(n2) 时间复杂度出现的主要原因还是因为我们<strong>分区点选的不够合理</strong>，最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多</strong>。</p>
<p>两个比较常用、比较简单的分区算法：</p>
<ol>
<li>三数取中法</li>
<li>随机法</li>
</ol>
<h1 id="二分查找（上）：如何用最省内存的方式实现快速查找功能？"><a href="#二分查找（上）：如何用最省内存的方式实现快速查找功能？" class="headerlink" title="二分查找（上）：如何用最省内存的方式实现快速查找功能？"></a>二分查找（上）：如何用最省内存的方式实现快速查找功能？</h1><p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p>
<p>二分查找的时间复杂度就是 O(logn)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 二分查找的循环实现</span><br><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low = 0;</span><br><span class="line">  int high = n - 1;</span><br><span class="line"></span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    int mid = (low + high) / 2;</span><br><span class="line">    if (a[mid] == value) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      high = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易出错的 3 个地方：</p>
<ol>
<li><p>循环退出条件</p>
<p>注意是 low&lt;=high，而不是 low。</p>
</li>
<li><p>mid 的取值</p>
<p>实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为相比除法运算来说，计算机处理位运算要快得多。</p>
</li>
<li><p>low 和 high 的更新</p>
<p>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如，当 high=3，low=3 时，如果 a[3] 不等于 value，就会导致一直循环不退出。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 二分查找的递归实现</span><br><span class="line">public int bsearch(int[] a, int n, int val) &#123;</span><br><span class="line">  return bsearchInternally(a, 0, n - 1, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int bsearchInternally(int[] a, int low, int high, int value) &#123;</span><br><span class="line">  if (low &gt; high) return -1;</span><br><span class="line"></span><br><span class="line">  int mid =  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">  if (a[mid] == value) &#123;</span><br><span class="line">    return mid;</span><br><span class="line">  &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">    return bsearchInternally(a, mid+1, high, value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return bsearchInternally(a, low, mid-1, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h2><ol>
<li>二分查找依赖的是顺序表结构，简单点说就是数组。</li>
<li>二分查找针对的是有序数据。</li>
<li><p>数据量太小不适合二分查找。</p>
<p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。</p>
</li>
<li><p>数据量太大也不适合二分查找。</p>
<p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p>
</li>
</ol>
<h1 id="二分查找（下）：如何快速定位-IP-对应的省份地址？"><a href="#二分查找（下）：如何快速定位-IP-对应的省份地址？" class="headerlink" title="二分查找（下）：如何快速定位 IP 对应的省份地址？"></a>二分查找（下）：如何快速定位 IP 对应的省份地址？</h1><p>4 种常见的二分查找变形问题：</p>
<ul>
<li>查找第一个值等于给定值的元素</li>
<li>查找最后一个值等于给定值的元素</li>
<li>查找第一个大于等于给定值的元素</li>
<li>查找最后一个小于等于给定值的元素</li>
</ul>
<h2 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h2><p>比如有序数组 a[10]={1, 3, 4, 5, 6, 8, 8, 8, 11, 18}， 使用上一节讲的二分查找算法，当得到 a[7]=8 时就返回了，但 a[7]并不是第一个等于 8 的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low = 0;</span><br><span class="line">  int high = n - 1;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    int mid =  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">    if (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - 1;</span><br><span class="line">    &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if ((mid == 0) || (a[mid - 1] != value)) return mid;</span><br><span class="line">      else high = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a[mid] 跟要查找的 value 的大小关系有三种情况：大于、小于、等于。对于 a[mid]&gt;value 的情况，我们需要更新 high= mid-1；对于 a[mid]&lt;value 的情况，我们需要更新 low=mid+1。这两点都很好理解。那当 a[mid]=value 的时候应该如何处理呢？</p>
<p>如果我们查找的是任意一个值等于给定值的元素，当 a[mid] 等于要查找的值时，a[mid] 就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当 a[mid] 等于要查找的值时，我们就需要确认一下这个 a[mid] 是不是第一个值等于给定值的元素。</p>
<h2 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low = 0;</span><br><span class="line">  int high = n - 1;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    int mid =  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">    if (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - 1;</span><br><span class="line">    &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if ((mid == n - 1) || (a[mid + 1] != value)) return mid;</span><br><span class="line">      else low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low = 0;</span><br><span class="line">  int high = n - 1;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    int mid =  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">    if (a[mid] &gt;= value) &#123;</span><br><span class="line">      if ((mid == 0) || (a[mid - 1] &lt; value)) return mid;</span><br><span class="line">      else high = mid - 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch7(int[] a, int n, int value) &#123;</span><br><span class="line">  int low = 0;</span><br><span class="line">  int high = n - 1;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    int mid =  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">    if (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if ((mid == n - 1) || (a[mid + 1] &gt; value)) return mid;</span><br><span class="line">      else low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变体的二分查找容易出错的细节有：<strong>终止条件、区间上下界更新方法、返回值选择</strong>。</p>
<h1 id="跳表：为什么-Redis-一定要用跳表来实现有序集合？"><a href="#跳表：为什么-Redis-一定要用跳表来实现有序集合？" class="headerlink" title="跳表：为什么 Redis 一定要用跳表来实现有序集合？"></a>跳表：为什么 Redis 一定要用跳表来实现有序集合？</h1><p>上两节讲了二分查找算法，其依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中还能不能使用二分查找算法？</p>
<p>实际上，我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫作<strong>跳表（Skip list）</strong>。它是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代<strong>红黑树（Red-black tree）</strong>。</p>
<p><img src="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_skip_list.jpg?raw=true" width="600"></p>
<p>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>跳表中查询任意数据的时间复杂度是 O(logn)。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>跳表的空间复杂度是 O(n)。</p>
<h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>跳表插入、删除操作的时间复杂度也是 O(logn)。</p>
<h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><h2 id="解答开篇-2"><a href="#解答开篇-2" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>Redis 中的有序集合支持的核心操作主要有下面这几个：</p>
<ul>
<li>插入一个数据；</li>
<li>删除一个数据；</li>
<li>查找一个数据；</li>
<li>按照区间查找数据（比如查找值在 [100, 356] 之间的数据)；</li>
<li>迭代输出有序序列。</li>
</ul>
<p>所以 Redis 用跳表来实现有序集合的原因有：</p>
<ul>
<li>插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高；</li>
<li>跳表更容易代码实现；</li>
<li>跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</li>
</ul>
<p><strong>但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现</strong>。</p>
<h1 id="散列表（上）：Word-文档中的单词拼写检查功能是如何实现的？"><a href="#散列表（上）：Word-文档中的单词拼写检查功能是如何实现的？" class="headerlink" title="散列表（上）：Word 文档中的单词拼写检查功能是如何实现的？"></a>散列表（上）：Word 文档中的单词拼写检查功能是如何实现的？</h1><p>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p>
<p>散列函数设计的基本要求：</p>
<ol>
<li>散列函数计算得到的散列值是一个非负整数；</li>
<li>如果 key1 = key2，那 hash(key1) = hash(key2)；</li>
<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</li>
</ol>
<p>在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的 MD5、SHA、CRC 等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining)。</p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。</p>
<p>重新探测空闲位置的方法有<strong>线性探测（Linear Probing）</strong>、<strong>二次探测（Quadratic probing）</strong>和<strong>双重散列（Double hashing）</strong>。</p>
<h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p><img src="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_sanliebiao_lianbiaofa.jpg?raw=true" width="600"></p>
<h2 id="解答开篇-3"><a href="#解答开篇-3" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。</p>
<p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p>
<h1 id="散列表（中）：如何打造一个工业级水平的散列表？"><a href="#散列表（中）：如何打造一个工业级水平的散列表？" class="headerlink" title="散列表（中）：如何打造一个工业级水平的散列表？"></a>散列表（中）：如何打造一个工业级水平的散列表？</h1><p>散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。</p>
<ul>
<li>如何设计散列函数</li>
</ul>
<p>首先，<strong>散列函数的设计不能太复杂</strong>，其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p>
<ul>
<li>避免装载因子过大</li>
</ul>
<p>针对散列表，当装载因子过大时，我们也可以进行<strong>动态扩容</strong>，重新申请一个更大的散列表，将数据搬移到这个新散列表中。</p>
<p>假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。</p>
<ul>
<li>避免低效地扩容</li>
</ul>
<p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。</p>
<p><img src="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_kuorong.jpg?raw=true" width="600"></p>
<p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。</p>
<ul>
<li>如何选择冲突解决方法</li>
</ul>
<p>当数据量比较小、装载因子小的时候，适合采用开放寻址法；基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>
<h2 id="工业级散列表举例分析（Java-中的-HashMap）"><a href="#工业级散列表举例分析（Java-中的-HashMap）" class="headerlink" title="工业级散列表举例分析（Java 中的 HashMap）"></a>工业级散列表举例分析（Java 中的 HashMap）</h2><ol>
<li>初始大小</li>
</ol>
<p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p>
<ol start="2">
<li>装载因子和动态扩容</li>
</ol>
<p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍。</p>
<ol start="3">
<li>散列冲突解决办法</li>
</ol>
<p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p>
<p>于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p>
<ol start="4">
<li>散列函数</li>
</ol>
<p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int hash(Object key) &#123;</span><br><span class="line">    int h = key.hashCode()；</span><br><span class="line">    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1); //capicity 表示散列表的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解答开篇-4"><a href="#解答开篇-4" class="headerlink" title="解答开篇"></a>解答开篇</h2><ul>
<li>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？<ul>
<li>支持快速的查询、插入、删除操作；</li>
<li>内存占用合理，不能浪费过多的内存空间；</li>
<li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</li>
</ul>
</li>
<li>如何实现这样一个散列表呢？<ul>
<li>设计一个合适的散列函数；</li>
<li>定义装载因子阈值，并且设计动态扩容策略；</li>
<li>选择合适的散列冲突解决方法。</li>
</ul>
</li>
</ul>
<h1 id="散列表（下）：为什么散列表和链表经常会一起使用？"><a href="#散列表（下）：为什么散列表和链表经常会一起使用？" class="headerlink" title="散列表（下）：为什么散列表和链表经常会一起使用？"></a>散列表（下）：为什么散列表和链表经常会一起使用？</h1><p>例子：</p>
<h2 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h2><p>用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。</p>
<p>一个缓存（cache）系统主要包含下面这几个操作：</p>
<ol>
<li>往缓存中添加一个数据；</li>
<li>从缓存中删除一个数据；</li>
<li>在缓存中查找一个数据。</li>
</ol>
<p>这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。</p>
<p><img src="https://github.com/Charles1198/Charles1198.github.io/blob/master/image/data_structure_lru.jpg?raw=true" width="600"></p>
<p>因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。</p>
<p>LRU 缓存淘汰算法的 3 个主要操作如何做到时间复杂度为 O(1)？</p>
<p>链表本身插入和删除操作复杂度是 O(1)，当要查找一个数据时，通过散列表可实现在 O(1)时间复杂度找到该数据，再加上前面说的插入或删除的时间复杂度是 O(1)，所以我们总操作的时间复杂度就是 O(1)。</p>
<h2 id="Redis-有序集合"><a href="#Redis-有序集合" class="headerlink" title="Redis 有序集合"></a>Redis 有序集合</h2><p>Redis 有序集合的操作：</p>
<ol>
<li>添加一个成员对象；</li>
<li>按照键值来删除一个成员对象；</li>
<li>按照键值来查找一个成员对象；</li>
<li>按照分值区间查找数据，比如查找积分在 [100, 356]之间的成员对象；</li>
<li>按照分值从小到大排序成员变量。</li>
</ol>
<h2 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h2><p>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构与算法/" rel="tag"># 数据结构与算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/15/Git常用命令速查表/" rel="next" title="Git常用命令速查表">
                <i class="fa fa-chevron-left"></i> Git常用命令速查表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/16/WebView中js与java&swift交互/" rel="prev" title="WebView中js与java/swift交互">
                WebView中js与java/swift交互 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/android-small.png" alt="Charles">
            
              <p class="site-author-name" itemprop="name">Charles</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/charles1198" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:charles@bqteam.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/565e70f260b21d713ddb5178" target="_blank" title="掘金">
                      
                        <i class="fa fa-fw fa-globe"></i>掘金</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/3953568239/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1#_rnd1514956922989" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么要学习数据结构和算法？"><span class="nav-number">1.</span> <span class="nav-text">为什么要学习数据结构和算法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何抓住重点，系统高效地学习数据结构与算法？"><span class="nav-number">2.</span> <span class="nav-text">如何抓住重点，系统高效地学习数据结构与算法？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#学习技巧："><span class="nav-number">2.0.1.</span> <span class="nav-text">学习技巧：</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"><span class="nav-number">3.</span> <span class="nav-text">复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#大-O-复杂度表示法"><span class="nav-number">3.1.</span> <span class="nav-text">大 O 复杂度表示法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间复杂度分析"><span class="nav-number">3.2.</span> <span class="nav-text">时间复杂度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几种常见时间复杂度实例分析"><span class="nav-number">3.3.</span> <span class="nav-text">几种常见时间复杂度实例分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空间复杂度分析"><span class="nav-number">3.4.</span> <span class="nav-text">空间复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"><span class="nav-number">4.</span> <span class="nav-text">复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组：为什么很多编程语言中数组都从-0-开始编号？"><span class="nav-number">5.</span> <span class="nav-text">数组：为什么很多编程语言中数组都从 0 开始编号？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念："><span class="nav-number">5.1.</span> <span class="nav-text">概念：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#警惕数组的访问越界问题"><span class="nav-number">5.2.</span> <span class="nav-text">警惕数组的访问越界问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-小知识"><span class="nav-number">5.3.</span> <span class="nav-text">java 小知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答开篇"><span class="nav-number">5.4.</span> <span class="nav-text">解答开篇</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表（上）：如何实现-LRU-缓存淘汰算法"><span class="nav-number">6.</span> <span class="nav-text">链表（上）：如何实现 LRU 缓存淘汰算法?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表-VS-数组性能大比拼"><span class="nav-number">6.1.</span> <span class="nav-text">链表 VS 数组性能大比拼</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#啥是-LRU-缓存淘汰算法"><span class="nav-number">6.2.</span> <span class="nav-text">啥是 LRU 缓存淘汰算法?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表（下）：如何轻松写出正确的链表代码？"><span class="nav-number">7.</span> <span class="nav-text">链表（下）：如何轻松写出正确的链表代码？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#技巧"><span class="nav-number">7.1.</span> <span class="nav-text">技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作者精选的-5-个常见链表操作"><span class="nav-number">7.2.</span> <span class="nav-text">作者精选的 5 个常见链表操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#栈：如何实现浏览器的前进和后退功能？"><span class="nav-number">8.</span> <span class="nav-text">栈：如何实现浏览器的前进和后退功能？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的应用"><span class="nav-number">8.1.</span> <span class="nav-text">栈的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#队列：队列在线程池等有限资源池中的应用"><span class="nav-number">9.</span> <span class="nav-text">队列：队列在线程池等有限资源池中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#循环队列"><span class="nav-number">9.1.</span> <span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞队列和并发队列"><span class="nav-number">9.2.</span> <span class="nav-text">阻塞队列和并发队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归：如何用三行代码找到“最终推荐人”？"><span class="nav-number">10.</span> <span class="nav-text">递归：如何用三行代码找到“最终推荐人”？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#递归需要满足的三个条件。"><span class="nav-number">10.1.</span> <span class="nav-text">递归需要满足的三个条件。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归代码要警惕堆栈溢出"><span class="nav-number">10.2.</span> <span class="nav-text">递归代码要警惕堆栈溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归代码要警惕重复计算"><span class="nav-number">10.3.</span> <span class="nav-text">递归代码要警惕重复计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么将递归代码改写为非递归代码？"><span class="nav-number">10.4.</span> <span class="nav-text">怎么将递归代码改写为非递归代码？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序（上）：为什么插入排序比冒泡排序更受欢迎？"><span class="nav-number">11.</span> <span class="nav-text">排序（上）：为什么插入排序比冒泡排序更受欢迎？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何分析一个“排序算法”？"><span class="nav-number">11.1.</span> <span class="nav-text">如何分析一个“排序算法”？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序（Bubble-Sort）"><span class="nav-number">11.2.</span> <span class="nav-text">冒泡排序（Bubble Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序（Insertion-Sort）"><span class="nav-number">11.3.</span> <span class="nav-text">插入排序（Insertion Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序（Selection-Sort）"><span class="nav-number">11.4.</span> <span class="nav-text">选择排序（Selection Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题：插入排序和冒泡排序的时间复杂度相同，都是-O-n²-，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？"><span class="nav-number">11.5.</span> <span class="nav-text">问题：插入排序和冒泡排序的时间复杂度相同，都是 O(n²)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序（下）：如何用快排思想在-O-n-内查找第-K-大元素？"><span class="nav-number">12.</span> <span class="nav-text">排序（下）：如何用快排思想在 O(n)内查找第 K 大元素？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序（Merge-Sort）"><span class="nav-number">12.1.</span> <span class="nav-text">归并排序（Merge Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序（Quicksort）"><span class="nav-number">12.2.</span> <span class="nav-text">快速排序（Quicksort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答开篇-1"><span class="nav-number">12.3.</span> <span class="nav-text">解答开篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">12.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线性排序：如何根据年龄给-100-万用户数据排序？"><span class="nav-number">13.</span> <span class="nav-text">线性排序：如何根据年龄给 100 万用户数据排序？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#桶排序（Bucket-sort）"><span class="nav-number">13.1.</span> <span class="nav-text">桶排序（Bucket sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计数排序（Counting-sort）"><span class="nav-number">13.2.</span> <span class="nav-text">计数排序（Counting sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序（Radix-sort）"><span class="nav-number">13.3.</span> <span class="nav-text">基数排序（Radix sort）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序优化：如何实现一个通用的、高性能的排序函数？"><span class="nav-number">14.</span> <span class="nav-text">排序优化：如何实现一个通用的、高性能的排序函数？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#优化快速排序"><span class="nav-number">14.1.</span> <span class="nav-text">优化快速排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二分查找（上）：如何用最省内存的方式实现快速查找功能？"><span class="nav-number">15.</span> <span class="nav-text">二分查找（上）：如何用最省内存的方式实现快速查找功能？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找应用场景的局限性"><span class="nav-number">15.1.</span> <span class="nav-text">二分查找应用场景的局限性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二分查找（下）：如何快速定位-IP-对应的省份地址？"><span class="nav-number">16.</span> <span class="nav-text">二分查找（下）：如何快速定位 IP 对应的省份地址？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查找第一个值等于给定值的元素"><span class="nav-number">16.1.</span> <span class="nav-text">查找第一个值等于给定值的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找最后一个值等于给定值的元素"><span class="nav-number">16.2.</span> <span class="nav-text">查找最后一个值等于给定值的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找第一个大于等于给定值的元素"><span class="nav-number">16.3.</span> <span class="nav-text">查找第一个大于等于给定值的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找最后一个小于等于给定值的元素"><span class="nav-number">16.4.</span> <span class="nav-text">查找最后一个小于等于给定值的元素</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#跳表：为什么-Redis-一定要用跳表来实现有序集合？"><span class="nav-number">17.</span> <span class="nav-text">跳表：为什么 Redis 一定要用跳表来实现有序集合？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#时间复杂度"><span class="nav-number">17.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空间复杂度"><span class="nav-number">17.2.</span> <span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高效的动态插入和删除"><span class="nav-number">17.3.</span> <span class="nav-text">高效的动态插入和删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳表索引动态更新"><span class="nav-number">17.4.</span> <span class="nav-text">跳表索引动态更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答开篇-2"><span class="nav-number">17.5.</span> <span class="nav-text">解答开篇</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#散列表（上）：Word-文档中的单词拼写检查功能是如何实现的？"><span class="nav-number">18.</span> <span class="nav-text">散列表（上）：Word 文档中的单词拼写检查功能是如何实现的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#散列冲突"><span class="nav-number">18.1.</span> <span class="nav-text">散列冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#开放寻址法"><span class="nav-number">18.1.1.</span> <span class="nav-text">开放寻址法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表法"><span class="nav-number">18.1.2.</span> <span class="nav-text">链表法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答开篇-3"><span class="nav-number">18.2.</span> <span class="nav-text">解答开篇</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#散列表（中）：如何打造一个工业级水平的散列表？"><span class="nav-number">19.</span> <span class="nav-text">散列表（中）：如何打造一个工业级水平的散列表？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#工业级散列表举例分析（Java-中的-HashMap）"><span class="nav-number">19.1.</span> <span class="nav-text">工业级散列表举例分析（Java 中的 HashMap）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答开篇-4"><span class="nav-number">19.2.</span> <span class="nav-text">解答开篇</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#散列表（下）：为什么散列表和链表经常会一起使用？"><span class="nav-number">20.</span> <span class="nav-text">散列表（下）：为什么散列表和链表经常会一起使用？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LRU-缓存淘汰算法"><span class="nav-number">20.1.</span> <span class="nav-text">LRU 缓存淘汰算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-有序集合"><span class="nav-number">20.2.</span> <span class="nav-text">Redis 有序集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-LinkedHashMap"><span class="nav-number">20.3.</span> <span class="nav-text">Java LinkedHashMap</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Charles</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">文章字数&#58;</span>
    
    <span title="文章字数">32.3k</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname, 
            owner: 'Charles1198',
            repo: 'gitment-comments',
            
            lang: "zh-Hans" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '5bfadc1f801e67cda3733d069713275fbf7c797d',
            
                client_id: '9f87bb5bb4c07b25414b'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    





  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'rD6LQY7VYp2sEhJJKp4McqeE-gzGzoHsz',
        appKey: 'L7zfWPqTQmmsjLysyERF6NH2',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("rD6LQY7VYp2sEhJJKp4McqeE-gzGzoHsz", "L7zfWPqTQmmsjLysyERF6NH2");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script>


</body>
</html>
